const router = require("express").Router();

// router-level middleware
router.use(async function(req,res,next){
    /**
     * we save result as an object with format:
     * code: custom status code generated by processing the request
     * msg: a short description of the custom status code
     * records: an array which will contain the mathed documents from dtabase collection 
     */
    res.locals.result = {
        code: 100,
        msg: "failed to connect to database.",
        records: null
    };
    next();
})

//request-method-level middleware
postMiddlewares = [
    /**
     * 
     * @param {object} req - request containing Content-Type header
     * @param {object} res - response result is sent if content-type does not match
     * @param {function} next - calls the next middleware if content-type is valid
     */
    function contentTypeValidation(req,res,next){
        res.locals.result = {
            code: null,
            msg: null,
            records: null
        };
        if(req.is('application/json')){
            res.setHeader("Content-Type", "application/json");
            next();
        } else {
            res.locals.result.code = 1;
            res.locals.result.msg = `Content-Type is wrong.`
            res.status(400).send(res.locals.result);
        }
    },
    /**
     * 
     * @param {object} req - contains path parameter describing the target collection in the database 
     * @param {object} res - response result is sent if target collection is not present in the database
     * @param {function} next - calls the next middleware is collection is matched
     */
    function collectionExists(req,res,next) {
        let collectionExists = false;
        for(let collectionName of req.app.locals.ykdbCollectionNamesList){
            if(collectionName === req.params.collection){
                collectionExists = true;
                break;
            }
        }
        if(collectionExists) next();
        else {
            res.locals.result.code = 2;
            res.locals.result.msg = `requested collection not found.`
            res.status(400).send(res.locals.result);
        };
    },
    /**
     * 
     * @param {object} req - contains the payload 
     * @param {object} res - response result is sent if payload is not found or its format is invalid
     * @param {function} next - calls the next middleware if payload format is valid
     */
    function payloadVlidation(req,res,next) {
        if(
            req.body === undefined ||
            Object.keys(req.body).length > 4 || 
            req.body.startDate === undefined || 
            req.body.endDate === undefined ||
            req.body.minCount === undefined || 
            req.body.maxCount === undefined
        ){
            res.locals.result.code = 3;
            res.locals.result.msg = "invalid request payload";
            res.status(400).send(res.locals.result);
        } else next();
    },
    /**
     * 
     * @param {object} req - contains the data provied in the payload
     * @param {object} res - response result is sent if payload data does not match requirements
     * @param {function} next - calls next function to process request after converting payload data as required 
     */
    function payloadDataValidation(req,res,next) {
        res.locals.startDate = new Date(
            req.body.startDate
        );
        res.locals.endDate = new Date(
            req.body.endDate
        );
        res.locals.minCount = Number(req.body.minCount);
        res.locals.maxCount = Number(req.body.maxCount);
        if(
            isNaN(res.locals.startDate) ||
            isNaN(res.locals.endDate) ||
            isNaN(res.locals.minCount) ||
            isNaN(res.locals.maxCount) ||
            req.body.minCount === null ||
            req.body.maxCount === null ||
            req.body.minCount !== ~~(req.body.minCount) ||
            req.body.maxCount !== ~~(req.body.maxCount) ||
            res.locals.minCount < 0 ||
            res.locals.maxCount < 0
        ){
            res.locals.result.code = 4;
            res.locals.result.msg = "Invalid format";
            res.status(400).send(res.locals.result);
        } else next();
    }
];

//routes
/**
 * @swagger
 * paths:
 *   /yk/{collection}:
 *     post:
 *       description: get filtered data from collections in yk database
 *       parameters:
 *         - name: collection
 *           in: path
 *           required: true
 *           schema:
 *             type: string
 *           description: the collection in the db that will be queried
 *         - name: payload
 *           in: body
 *           required: true
 *           schema:
 *             $ref: '#/components/schemas/payload'
 *           description: payload data required to filter query results
 * 
 *       responses:
 *         '200':
 *           description: OK
 * 
 * components:
 *   schemas:
 *     payload:
 *       type: object
 *       properties:
 *         startDate:
 *           type: string
 *           example: 2016-02-22
 *           description: all documents created before start date will be filtered out
 *         endDate:
 *           type: string
 *           example: 2018-08-15
 *           description: all documents created after start date will be filtered out
 *         minCount:
 *           type: integer
 *           example: 4
 *           description: all documents whose counts array has elements less than minCount will be filtered out
 *         maxCount:
 *           type: string
 *           example: 7
 *           description: all documents whose counts array has elements greater than minCount will be filtered out
 */
router.post("/:collection",postMiddlewares,async function(req,res){
    try{
        let ykdb = req.app.locals.ykdb;
        /**
         * mongodb aggregation pipeline to be run on any collection in yk database:
         * this pipe line has 3 stages
         */
        let pipeline = [
            /**
             * first stage: matches all documents whose 
             *  createdAt field has Date greater
             *  than and equal to startDate and less 
             *  than and equal to endDate in
             *  provided in request body parameters.
             *  the time of day is 00 hours,00 minutes,
             *  00 seconds for each date unless request
             *  parameter has valid date string including
             *  a time of day.
             */
            { 
                $match : {
                    createdAt: { 
                    $gte: res.locals.startDate, 
                    $lte: res.locals.endDate }
                }
            },
            /**
            * second stage: projects key field, createdAt
            *  field and totalCount field of
            *  all filtered documents after aggregating
            *  the size of their counts array
            *  to totalCount field
             */
            {
                $project: {
                    _id: 0,
                    key: 1,
                    createdAt: 1,
                    totalCount: { 
                        $cond: { 
                            if: { $isArray: "$counts" }, 
                            then: { $size: "$counts" }, 
                            else: "NA"
                        } 
                    }
                }   
            },
            /**
            * third stage: filters projected documents from 
            *  previous stage by their totalCount
            *  field matching only those that have values
            *  greater than and equal to minCount and
            *  less than and equal to maxCount as 
            *  provided in request bosy parameters. 
            */
            { 
                $match : { 
                    totalCount: { 
                        $gte: res.locals.minCount, 
                        $lte: res.locals.maxCount 
                    } 
                } 
            }
        ];
        let cursor = await ykdb.collection(
            req.params.collection
        ).aggregate(pipeline);
        const data = await cursor.toArray();
        res.locals.result.code = 0;
        res.locals.result.msg = "success";
        res.locals.result.records = data;
        res.status(200).send(res.locals.result);
    } catch(err){
        console.log(err.stack);
        res.status(400).send({code:5,msg:"bad request.",records:null});
    }
});

module.exports = router;